:revdate: {docdate}
:version-label!: 
:sectnums:
:sectnumlevels: 5 
:chapter-label: Validation
:source-highlighter: rouge

## Validation

The active manifest of an asset is valid only if all the steps in this section are successful. This validation must be completed before a validator presents a successful result to a human user or begins to render any content. Validating content as it is rendered to the user is described in <<_validate_the_assets_content>>.

### Locating the Active Manifest

The last C2PA Manifest superbox in the C2PA Manifest Store superbox is the active manifest, but locating the C2PA Manifest Store may involve looking in a number possible locations.

#### Embedded

The manifest consumer shall look inside the asset for an embedded C2PA Manifest Store in the xref:_embedding_manifests_into_assets[standard locations for embedding manifests] to see if one is present.  
 
#### By Reference/URI

If there is no embedded C2PA Manifest Store, the following attempts should be made to locate one at a remote location.

- If the asset was retrieved via an HTTP connection, the manifest consumer should look in the header of the HTTP response for a `Link` header, as defined in https://datatracker.ietf.org/doc/html/rfc8288[RFC 8288], containing a parameter of `rel=c2pa-manifest`. If present, a C2PA Manifest Store can be retrieved from that URI reference.

.Note 1
NOTE: HTTP refers to the _Hypertext Transfer Protocol_ defined in https://tools.ietf.org/html/rfc7230[RFC 7230], not the specific URL scheme `http://`.


- If the asset has XMP and the XMP contains a `dcterms:provenance` key, the provided URI should be used to locate the active manifest.

- If no C2PA Manifest Store has been located, the manifest consumer should look for files at the same path or URI, but with a filename extension of `.c2pa`. If the C2PA Manifest Store is not found, a manifest consumer may look in whatever additional places it deems most appropriate to locate it.  For example, a child folder of a file system.

.Note 2
NOTE: A manifest consumer is not restricted to only the above locations, it can choose to look in additional locations as well.

[NOTE]
.Editors Note
====
The C2PA will work with the ISO JPEG Systems committee to register a media type for JUMBF with IANA.
====

##### Validating a Match

A manifest consumer may wish to validate that the located C2PA Manifest Store is indeed the one associated with asset. 

If the C2PA Manifest Store was located then the hard binding assertions present in its active manifest shall be used to validate that it is the matching manifest and whether the asset has been modified without manifest updates. If the hard bindings do not match, it is unknown if that is because of (a) modification of the asset or (b) the wrong C2PA Manifest Store was located. Accordingly, the manifest consumer shall treat this as non-matching hard bindings and reject the manifest.

### Locating the Claim

Once an active manifest has been located, the claim is found by locating, within the active manifest, the JUMBF Superbox with a label of `c2pa.claim` and a UUID of `0x6332636C-0011-0010-8000-00AA00389B71` (`c2cl`).  There shall only be one such box in the active manifest, if more than one is located, the manifest shall be rejected.

### Validate the Signature

Retrieve the URI reference for the signature from the value of the claim's `signature` field and resolve the URI reference to obtain the COSE signature. The signature must be embedded in the same manifest as described in <<_c2pa_box_details>>. If the signature URI does not refer to a location within the same manifest box (a `self#jumbf` location), the claim must be rejected. If no such field is present or the URI cannot be resolved, then the claim must be rejected.

Validate that the credential used in the signature is acceptable according to <<_trust_model>>. If it is not, then the claim must be rejected. After confirming it is acceptable, validation should proceed according to the specified procedure in <<_digital_signatures>>. If validation of the signature fails, then the claim must be rejected.

For the remainder of this chapter, headers refer to the union of the set of protected and unprotected header parameters in the COSE signature. Unless otherwise specified in <<_digital_signatures>> or <<_credential_types>>, a header may appear in either bucket. https://datatracker.ietf.org/doc/html/rfc8152#section-3[RFC8152 section 3] describes COSE headers.

### Validate the Time-Stamp

If the `sigTst` header is not present, the claim is valid if the signer's credential is valid at the current time.

If the `sigTst` header is present, the claim is valid if the `tstTokens` array contains at least one `tstToken` whose `val` property is an RFC3161-compliant `TimeStampResp` which satisfies the following requirements:

* The time-stamp contains a message imprint as described in <<_time_stamps>> that matches the claim being validated,
* The time attested by the Time Stamp Authority (TSA) falls within the validity period of the signing credential,
* The attested time falls within the validity period of the TSA's signing certificate,
* A trust chain can be built to an entry in the TSA trust store as described in <<_signer_credential_trust>>. Locating the TSA's certificate in the `TimeStampResp` is described in https://datatracker.ietf.org/doc/html/rfc3161#section-2.4.1[RFC 3161 section 2.4.1].

[NOTE]
At this time, the revocation status of a Time Stamp Authority's certificate is neither captured at signing time nor validated at validation time.

### Validate the Credential Revocation Information

If the signer's credential type does not support revocation status, or the credential's issuer did not provide a method to query its revocation status, the validator presumes the credential is not revoked.

If the signer's credential type supports revocation, and the credential's issuer provided a method to query its revocation status:

* If the `rVals` header is present, its contents shall be validated as described in <<_credential_types>> for the signer credential type.

* If the `rVals` header is not present, and the signer's credential is considered valid by the requirements of <<_validate_the_signature>> and <<_trust_model>>, a validator may choose to query the credential status method to determine if the credential is currently revoked.
** If the validator does not query the credential status, the validator shall presume the credential is not revoked.
** If the validator does query the credential status, it shall determine the status from the response as described in <<_credential_types>> for the signer's credential type.

[NOTE]
Querying the credential status method can reveal to an observer the identity of the asset being validated, and so this query is optional.

[NOTE]
When a signer's credential is revoked, this does not invalidate manifests that were signed before the time of revocation. The inclusion of the `rVals` header combined with a time-stamp provides proof that the signer's credential was valid at the time of signing. Signers are encouraged to include revocation information and time-stamps to avoid the necessity of a query at validation time.

In all cases, if the credential is deemed revoked at the time of signing, the claim shall be rejected.

### Validate the Assertions

#### Validate the correct assertions for the type of manifest

Depending on the xref:_types_of_manifests[type of manifest], there are assertions that are either required or forbidden. A validator shall check for required and not-permitted assertions.

. If it is a xref:_standard_manifests[standard manifest]
.. Validate that there is at least one xref:_binding_to_content[hard binding to content] assertion - either a `c2pa.hash.data` or a `c2pa.hash.bmff` based on the type of asset for which the manifest is destined.  If not, the manifest must be rejected.
.. Validate that there are zero or one `c2pa.ingredient` assertions whose `relationship` is `parentOf`.  If there is more than one, the manifest must be rejected.
. If it is an xref:_update_manifests[update manifest]
.. Validate that there are not any `c2pa.hash.data`, `c2pa.hash.bmff` or `c2pa.actions` assertions.  If there are, the manifest must be rejected.
.. Validate that there is exactly one `c2pa.ingredient` assertion and whose `relationship` is `parentOf`.  If there is not (i.e., either it is missing, there are more than one, or the value of `relationship` is not `parentOf`), the manifest must be rejected.

#### Preparing the list of redacted assertions

For each manifest, there may be a set of its assertions that were redacted from it. The list of those assertions is not found in the manifest itself but instead in a manifest that references it as an ingredient. Therefore a validator, when processing a claim, shall gather the set of redacted assertion for each ingredient manifest based on each `hashed_uri` listed in the `redacted_assertions` field. A claim's `redacted_assertions` field shall never include a `hashed_uri` to any of its own assertions.

#### Assertion Validation

Each assertion in the `assertions` field of the claim is a `hashed_uri` structure. For each assertion, the validator must: 

. If the URI reference in the `url` field is in the xref:_preparing_the_list_of_redacted_assertions[list of redacted assertions]:
.. If the assertion's label is `c2pa.actions`, the claim must be rejected as `c2pa.actions` assertions shall not be redacted.
.. Otherwise, the redacted assertion is considered valid, and validation continues to the next assertion.
. For all other assertions:
.. Resolve the URI reference in the `url` field to obtain its data. If the URI does not refer to a location within the same manifest box (a `self#jumbf` location), the claim must be rejected. If the URI cannot be resolved and the data retrieved, the claim must be rejected.
... If the assertion's label is `c2pa.cloud-data`:
.... If the `label` field of the external assertion is `c2pa.hash.data` or `c2pa.hash.bmff`, the claim must be rejected.
.... If the manifest is an update manifest and the `label` field of the external assertion is `c2pa.actions`, the claim must be rejected.
... Compute a hash of the data using the hash algorithm, determined by following the procedure described in <<_hashing>>:
.... If an `alg` field is present in the `hashed_uri` structure, that determines the hash algorithm.
.... If an `alg` field is not present in the `hashed_uri` structure, an `alg` field must be present in an enclosing structure, and the nearest instance present determines the hash algorithm.
.... If no `alg` field is found in any of these locations:
..... If an `alg` field is present in the claim, that determines the hash algorithm.
..... If no `alg` field is present in the claim, the claim must be rejected.
... Compare the computed hash value with the value in the `hash` field. If they do not match, the claim must be rejected.
... Otherwise, the assertion is valid and validation continues to the next assertion.

Then, for each element of the claim's own `redacted_assertions` array, if any element of the claim's `assertions` array has a `url` field equal to that value, the claim must be rejected. A claim cannot redact its own assertions, only those of its ingredients.

[NOTE]
As described in <<_w3c_verifiable_credentials>>, any proofs present inside a Verifiable Credential are not validated. Like all contents of an assertion, C2PA only guarantees the contents of the credential are integrity-protected.

#### External Data Validation

The contents of a xref:_cloud_data[cloud data assertion], which contains the URI references to and hashes of external data, are validated like any other assertion, but those references are not retrieved and validated as part of standard validation. A validator must first successfully validate a claim before attempting to retrieve external data listed in a cloud data assertion. A validator must not attempt to retrieve external data from a rejected claim. As the retrieval of external data is optional, the inability to retrieve or validate external data shall not cause a claim to become rejected.

If a validator chooses to retrieve any of the external data in a cloud data assertion, the validator must:

. First, determine the hash algorithm to be used.
.. If an `alg` field is present in the `hashed_ext_uri` structure, that determines the hash algorithm. If an `alg` field is not present, the validator must abort the attempt to retrieve the external data.
+
[NOTE]
The `alg` field is mandatory in `hashed_ext_uri`, so no recursive procedure to determine the hash algorithm is required.
+
. Resolve the URI reference in the `url` field to obtain its data. If the URI cannot be resolved and the data retrieved, the validator must abort the attempt to retrieve the external data.
. If the size of the retrieved data is not equal to the value of the `size` field, the validator must return an error to the application and not provide the retrieved data.
. If the content type of the retrieved data, as determined by the `Content-Type` header of the HTTP response, is not equal to the value of the `content_type` field, the validator must return an error to the application and not provide the retrieved data.
. Compute a hash of the data using the hash algorithm, determined by following the procedure described in <<_hashing>>:
.. Compare the computed hash value with the value in the `hash` field. If they do not match, the validator must return an error to the application and not provide the retrieved data.
.. Otherwise, the retrieved data is successfully provided to the aplication.

### Recursively Validating Integrity of Ingredients

A validator must perform the above validation steps for the asset being presented and its manifest. If any of the above steps conclude the manifest is invalid, that manifest must be rejected.

An asset's manifest may list one or more ingredients. For standard manifests, a validator may choose to optionally recurse through any ingredient manifests, however the `parentOf` ingredient of an update manifest shall be validated by the procedure below. There is no requirement that signers of ingredient manifests are trusted by the validator, and building of trust chains of signers of ingredients shall not be attempted. Instead, as the ingredient is included by the signer of the active manifest, and if the signer of the active manifest is accepted per the rules above, ingredient manifests will share in that trust for the purposes of this recursive validation. Applications should not display data from ingredient manifests with failed integrity checks. If the application chooses to display such data, it must flag the display with a warning about the failed integrity check, and that the data cannot be reliably attributed to the ingredient manifest's signer nor to the asset's manifest's signer.

When ingredients are being added to an asset as part of an authoring workflow, the ingredient may undergo full validation and the results expressed in a xref:_existing_manifests[validation status]. In this scenario, the ingredient's manifest is considered the active manifest for validation purposes, before the ingredient is added to another asset's ingredients.

For consumption scenarios, it is expected that problems with ingredient manifests from a standard manifest would be ignored during normal consumption use but may be surfaced as a warning if a user opts to explore the provenance history. However, the `parentOf` ingredient of an update manifest shall be surfaced. 

In authoring scenarios, it may be desirable to more prominently raise warnings so that a creator making use of such an asset with a flawed provenance history can make an informed decision of how to proceed.

If the manifest is an update manifest, or if a validator chooses to validate the ingredients of a standard manifest, then for each ingredient, it must recursively:

* If the ingredient does not have a `c2pa_manifest` field
. If the manifest is a standard manifest, then the ingredient is accepted. 
. If the manifest is an update manifest, then the claim must be rejected.
* If the ingredient does have a `c2pa_manifest` field:
. Create an xref:_preparing_the_list_of_redacted_assertions[list of redacted assertions] which is the concatenation of the claim's `redacted_assertions` array with any pre-existing redacted assertions list from previous recursive calls. This list is therefore only the redacted assertions from the active manifest's claim and any ingredients along the path to the current ingredient.
. Resolve the URI reference in the `url` field to obtain the ingredient claim's manifest. If the URI reference cannot be resolved, the ingredient claim is rejected. If the URI reference refers to an external location, and a temporary failure prevents retrieval of the claim, the claim cannot be accepted until it is retrieved. The validator may indicate this temporary failure status.
. Determine the hash algorithm identifier as determined by following the procedure described in <<_hashing>>: 
.. If an `alg` field is present in the `hashed_uri` structure, that determines the hash algorithm.
.. If an `alg` field is not present in the `hashed_uri` structure, an `alg` field must be present in an enclosing structure, and the nearest instance present determines the hash algorithm.
.. If no `alg` field is found in any of these locations, the claim must be rejected.
. Compute the hash of the ingredient manifest's data using that algorithm.
. Compare the computed hash with the value in the `hash` field. If the hashes are not equal, the claim must be rejected.
. If the ingredient contains a `validationStatus` field, and its `code` field equals a failure code, as defined at <<_failure_codes>>, the ingredient's claim is admitted. An admitted manifest is treated like an accepted manifest, but with an explicit indication that it may contain validation errors that are known to the signer. If admitted in this way, the validator must present the contents of the `validationStatus` field as part of any exploration of the provenance history. Validators should perform full validation if exploration of the provenance history of the ingredient is requested to indicate where there are validation errors.
+
[NOTE]
The presence of a `validationStatus` with a failure code is an explicit statement by the signer that they acknowledge and override validation errors in the ingredient's claim itself.
+
. Otherwise, validate the ingredient claim and assertions as described beginning in <<_validate_the_signature>>, except skip establishing signer credential trust, as this is not applicable to ingredients.
.. When validating the assertions as described in <<_validate_the_assertions>>, provide a xref:_preparing_the_list_of_redacted_assertions[list of redacted assertions] as an input. 
.. The validator may optionally recursively validate the ingredient's ingredients. If it does and those are accepted, the ingredient's claim is accepted. If any are rejected, the ingredient's claim is rejected. If the validator chooses not to recurse further, the ingredient's claim is accepted.

### Visual look of Validation

Here is a visual representation of the process of validating a claim (and its assertions).

.Validating a Claim
ifdef::backend-html5,backend-pdf[]
image::images/Claim_Validation.svg[Validating a Claim,width=720,height=432,align="center"]
endif::[]
ifdef::backend-docbook5[]
image::images/Claim_Validation.png[Validating a Claim,width=720,height=432,align="center"]

endif::[]

### Validate the Asset's Content 

If the active manifest is an update manifest, its <<_hard_bindings>> are inherited from the `parentOf` ingredient's manifest. If that manifest is also an update manifest, the search for a standard manifest shall recurse though the chain of ingredients.  If no standard manifest is found, then the manifest shall be rejected.

#### Validating a data hash

Once a standard manifest (and its bindings) has been located, the exclusion range(s) shall be extracted from the `c2pa.hash.data` assertion. 

If any update manifests were encountered then the `length` value of the exclusion range whose `start` value is the offset of the start of the entire C2PA manifest store shall be treated as the current length of the entire C2PA manifest store plus any file format specific extras.

The hash algorithm (`alg`) specified in that `c2pa.hash.data` shall be computed over the bytes of the asset, minus those specified in the exclusion range(s). 

If the resultant hash does not match the value of the `hash` field in the `c2pa.hash.data`, then the manifest shall be rejected.

##### Hashing of JPEG-1 files

In JPEG-1 files, the file format extras described above would include any `APP11` markers and their respective segment length bytes for `APP11` segments.  Because the segment lengths are inside the exclusion range, a validator shall match the total length of the exclusion range with that of the total length of all `APP11` segments representing the C2PA Manifest to ensure that the length was not tampered with.

NOTE: A JPEG-1 file can contain `APP11` segments for reasons other than C2PA (e.g., JPEG 360 or JPSec) and those are not included in these calculations.


#### Validating a BMFF-hash

For any portions of an asset rendered for presentation to a user, including but not limited to audio, video, or text, the corresponding hard bindings corresponding to the rendered content must be validated in accordance with <<_hard_bindings>>. If at any time content fails to be validated, the validator must clearly signal to the user that some of the content does not match the claim, and if possible, should indicate what part of the content did not validate. If any content is absent for which content bindings exist, discovery of this absence is also a validation failure. The validator must continue to report validation has failed, even if later portions of the content validate correctly.

For content that is not wholly available before rendering begins, such as during adaptive bitrate streaming (ABR) and progressive download, absence of not-yet-available portions of content is not considered a validation failure. As the content becomes available, the validator must validate each portion of the content before it is rendered as previously described. In addition, the validator must validate that the sequence of said content is the same as when the manifest was produced. Unless the player has explicitly signalled the validator that a discontinuity is expected (e.g., when the consumer performs a manual seek operation via the UI), the validator must clearly signal to the user that an unexpected discontinuity has occurred whenever the sequence does not match.

For content that is intentionally not being rendered as the claim generator originally intended, such as during fast-forward, rewind, or playback at a different speed, the validator may not be able to validate the content. In this case, the validator must clearly signal to the user that the content cannot be validated during the corresponding operation.

