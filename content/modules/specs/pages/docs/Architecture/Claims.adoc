## Claims

### Overview

A *claim* gathers together all the assertions about an asset from an actor at a given time including the set of assertions for xref:_binding_to_content[binding to the content]. The claim is then cryptographically hashed and signed as described in <<_signing_a_claim>>. A claim has all the same properties as an assertion including being assigned a label (`c2pa.claim`). 

### Syntax

The https://datatracker.ietf.org/doc/html/rfc8610[CDDL Definition] for this type is:

[source,cddl]
----
include::../../schemas/cddl/claim.cddl[]
----

An example in https://www.rfc-editor.org/rfc/rfc8949.html#name-diagnostic-notation[CBOR-Diag] is shown below:

[source,json]
----
include::../../schemas/cddl/examples/claim.cbordiag[]
----

The https://www.iana.org/assignments/media-types/media-types.xhtml[Media Type] of the ingredient shall be declared in `dc:format`. If present, the value of `dc:title` shall be a human-readable name for the asset. 

If the asset contains XMP, then the asset's `xmpMM:InstanceID` should be used as the `instanceID`. When no XMP is available, then some other xref:_unique_identifiers[unique identifier] for the asset shall be used as the value for `instanceID`. 

NOTE: Some field names, such as `dc:format`, have namespace prefixes as their names and definitions are taken directly from the XMP standard.  However, their usage in C2PA does not require the use of XMP.

The value of `claim_generator` is a human-readable string that will let a user know what software/hardware/system produced this Claim.  This field shall be present and its value shall be a string that conforms to the User-Agent string format specified in section 5.5.3 of http://tools.ietf.org/html/rfc7231#section-5.5.3[ HTTP/1.1 Semantics and Content].

The `signature` field shall be present containing a xref:_uri_references[URI reference] to a xref:_signing_a_claim[claim signature].

The `assertions` field shall be present containing one or more xref:_uri_references[URI references] to the xref:_assertions[assertions] being made by this claim. 

When present, the `redacted_assertions` field shall contain one or more xref:_uri_references[URI references] to xref:_redaction_of_assertions[redacted assertions].

### Creating a Claim

#### Creating Assertions

Before the claim can be finalized, all xref:_assertions[assertions] must be created and stored in a newly created xref:_c2pa_box_details[C2PA Assertion Store] as described xref:_types_of_manifests[later in this document].

When creating a standard manifest, it may not be possible to know all of the required binding information at the time of claim creation, in which case use the xref:_multiple_step_processing[multiple step processing method] to setup and then later fill-in the information.

#### Preparing the Claim

##### Adding Assertions and Redactions

The claim shall contain the `assertions` field and its value is a list of all of the URI references for all assertions that were added to the assertion store that are being "claimed" by this claim. At least one of the assertions shall be either a xref:_data_hash[data hash assertion] or a xref:_bmff_based_hash[BMFF-based hash assertion].

If any assertions in ingredient claims are being redacted, their URI references shall be added to list which is the value of the `redacted_assertions` field.

##### Adding Ingredients

In many authoring scenarios, an actor does not create an entirely new asset but instead brings in other existing assets on which to create their work - either as a derived asset, a composed asset or an asset rendition. These existing assets are called ingredients and their use is documented in the provenance data through the use of an xref:_Ingredients[ingredient assertion]. When an ingredient contains one or more C2PA manifests, those manifests must be inserted into this asset to ensure that the provenance data is kept intact. Such ingredient manifests are added to the JUMBF as described in <<_c2pa_box_details>>.

##### Connecting the Signature

The signature cannot be part of the signed payload, but since its label is pre-defined, then the full URI reference is also known. As such, we can include that in the claim by setting the value of the `signature` field of the claim to that URI reference.

NOTE: This provides the explicit binding of the claim to its signature.

##### Signing a Claim

Producing the signature is specified in <<_digital_signatures>>. The `payload` field of `Sig_structure` shall be the serialized CBOR of the claim document. The serialized `COSE_Sign1_Tagged` structure resulting from the digital signature procedure is written into the C2PA Claim Signature box.

##### Time-stamps

If possible, the signer should use a RFC3161-compliant Time Stamp Authority (TSA) (https://datatracker.ietf.org/doc/html/rfc3161[RFC 3161 section 1]) to obtain a trusted time-stamp proving that the signature itself actually existed at a certain date and time and incorporate that into the `COSE_Sign1_Tagged` structure as a countersignature. A manifest may contain multiple time-stamps.

[NOTE]
Signers are encouraged to obtain and include time-stamps to ensure their manifests will remain valid. As described in <<_validation>>, manifests without time-stamps cease to be valid when the signing credential expires or becomes revoked.

All time-stamps shall be obtained as described in https://tools.ietf.org/html/rfc3161[RFC3161] with the following additional requirements:

* The `MessageImprint` of the `TimeStampReq` structure (https://datatracker.ietf.org/doc/html/rfc3161#section-2.4.1[RFC 3161 section 2.4.1]) shall be computed by creating the `ToBeSigned` value in https://datatracker.ietf.org/doc/html/rfc8152#section-4.4[RFC 8152 section 4.4] with the following values for elements of `Sig_structure`:
** The `context` element shall be `CounterSignature`. 
** The `payload` element shall be as described in <<_signing_a_claim>>
** The remaining elements of `Sig_structure` are as described in <<_digital_signatures>>.
* The `ToBeSigned` value is then hashed using a hash algorithm from the allowed list in <<_hashing>> that the TSA supports, and that hash algorithm and value are placed in the `MessageImprint`. If the TSA does not support any hash algorithms from the allowed list, it cannot be used for time-stamping.
** Where possible, the hash algorithm should use the same hash algorithm used in the digital signature of the claim.
* The `certReq` boolean of the `TimeStampReq` structure shall be asserted in the request to the TSA, to ensure its certificate chain is provided in the response. 

Time-stamps shall be stored in a COSE unprotected header whose key is the string `sigTst`. If no time-stamps are included, the header shall be absent. When present, the value of this header shall be a `tstContainer` defined by the following CDDL:

[source,cddl]
----
include::../../schemas/cddl/tstContainer.cddl[]
----

The content of the `TimeStampResp` structure received in reply from the TSA shall be stored as the value of the `val` property of an element of `tstTokens`.

[NOTE]
The above definition is a CBOR adaptation of a subset of the schema from https://www.etsi.org/deliver/etsi_ts/119100_119199/11918201/01.01.01_60/ts_11918201v010101p.pdf[JAdES section 5.3.4] and https://forge.etsi.org/rep/esi/x19_182_JAdES/raw/v1.1.1/19182-jsonSchema.json[its JSON schema], except with the modification that the content of `val` is a byte string containing the content of the `TimeStampResp`, and not a Base64-encoded version of the same.

##### Credential Revocation Information

If the signer's credential type supports querying online credential status, and the credential contains a pointer to a service to provide time-stamped credential status information, the signer should query the service, capture the response, and store it in the manner described for the signer's credential type in the xref:_trust_model[Trust Model]. If credential revocation information is attached in this manner, a trusted time-stamp must also be obtained after signing, as described in <<_time_stamps>>.


#### Examples

##### Single Claim

Here is a visual representation of an image containing a single claim with multiple assertions that have been embedded inside it.

.A single claim with assertions
ifdef::backend-html5,backend-pdf[]
image::images/Single_Claim.svg[A single claim with assertions,width=720,height=432,align="center"]
endif::[]
ifdef::backend-docbook5[]
image::images/Single_Claim.png[A single claim with assertions,width=720,height=432,align="center"]
endif::[]

##### Multiple Claims

In this example of creating a second claim for the xref:_single_claim[previous example], one of the original assertions has been redacted from the previous claim. The visual representation for this scenario would look like:

.Redacting assertions in a secondary claim
ifdef::backend-html5,backend-pdf[]
image::images/Multiple_Claims.svg[Redacting assertions in a secondary claim,width=720,height=432,align="center"]
endif::[]
ifdef::backend-docbook5[]
image::images/Multiple_Claims.png[Redacting assertions in a secondary claim,width=720,height=432,align="center"]
endif::[]


### Multiple Step Processing

Some asset file formats require file offsets of the C2PA Manifest Store and asset content to be fixed before the manifest is signed, so that content bindings will correctly align with the content they authenticate. Unfortunately, the size of a manifest and its signature cannot be precisely known until after signing, which could cause file offsets to change. For example, in https://en.wikipedia.org/wiki/JPEG[JPEG-1] files, the entire C2PA Manifest Store must appear in the file before the image data, and so its size will affect the file offsets of content being authenticated.

To accomplish this, a multiple step approach is taken, similar to how signatures in PDF are done.

#### Prepare the XMP

For those C2PA-enabled assets that contain embedded XMP, start by creating the XMP data stream and then serializing it into the asset in the standard location reserved for it in the format of the asset. The XMP stream may include the xref:_embedding_a_reference_to_the_active_manifest[active manifest reference].  

NOTE: While it is possible to add the XMP data to the list of exclusions in a data hash assertion, doing so is not recommended as it would remove tamper detection of that asset metadata.

#### Create content bindings

When creating a xref:_standard_manifest[standard manifest], its claim shall include one or more content binding assertions in its list of assertions to ensure that the asset is tamper-evident. 

In many cases, such as with JPEG-1, it is not possible to hash the asset in its entirety because the manifest will be embedded in the middle of the file, so the size or location manifest data will not be known at the time the asset hash is calculated.  This circular dependency is avoided by allowing exclusion ranges to be specified during hashing.  When exclusion ranges are specified, a single hash is performed, but only over the asset ranges that are not in any of the exclusions.

For example, if a manifest is embedded in the center of a JPEG-1 file in an APP11 segment, then the claim creator can exclude the APP11 segment(s) from the hash calculation.

In order to prevent insertion attacks, it is desirable to have only a single exclusion range when possible. When the size or location (or both) of the manifest in the asset is not known, then the `start` and `length` values in the data hash assertion shall both be zero and the size of the `pad` value should be large enough to accommodate writing in the values in the second pass.  At least 16 bytes is recommended.

Create the data hash assertion and add it to the assertion store.  

#### Create a temporary Claim and Signature

Add the newly created data hash assertion reference to the claim's assertion list providing a temporary hash value, such as empty spaces.

At this point, the temporary claim is complete and can be added to the C2PA Manifest being created.

Since the claim is only temporary at this time, it is not possible to sign it. To ensure the claim signature box contains a valid CBOR structure, create a temporary `COSE_Sign1_Tagged` structure as described in https://datatracker.ietf.org/doc/html/rfc8152#section-4.2[RFC 8152 section 4.2]. The `COSE_Sign1_Tagged` is a tag byte followed by a `COSE_Sign1` structure, which is a four-element CBOR array. Construct the array as follows:

* The first element is the `protected` header bucket (https://datatracker.ietf.org/doc/html/rfc8152#section-3[RFC 8152 section 3]). Create an empty bucket by placing a `bstr` of size 0 in this position.
* The second element is the `unprotected` header bucket, which is a CBOR map. Create a map of 1 pair. Use the string `pad` as the map key, and place a `bstr` of the desired padding size filled with zero bytes as the value. A 25 kilobyte size is recommended for the initial size of this padding.
* The third element is the `payload`. Place the value `nil` (CBOR major type 7, value 22) here.
* The fourth element is `signature`. Place a `bstr` of size 0 here.

#### Complete the C2PA Manifest

At this point all of the boxes that comprise the entire C2PA Manifest for the asset are completed and can be (if not already) constructed into its final form. The asset's C2PA Manifest, along with the manifests of any ingredients, are combined together to form the complete C2PA Manifest Store. The active manifest must be the last C2PA Manifest superbox in the C2PA Manifest Store superbox. The C2PA Manifest Store can then be embedded into the asset as discussed in <<_embedding_manifests_into_assets>>.

#### Going back and filling in

Now that the C2PA Manifest Store has been embedded into the asset, the starting offset and the length of the active manifest can be updated in its data hash assertion.  It is necessary that when doing so, you don't change the size of the assertion's box, only its data.  This is done by adjusting the value of the `pad` field to be the necessary length to "fill up" the remaining bytes.

Once the data hash assertion has been updated, it can be hashed and the hash written over the empty spaces that were used previously to hold the location. 

The claim is now complete, and it can be hashed and signed as described in <<_signing_a_claim>>, with the resultant signature filling the pre-allocated space. The `pad` header can then be shrunk as required so that the claim signature box remains the same size; because this header is unprotected, changing it does not invalidate the claim signature. 

If the serialized `COSE_Sign1_Tagged` structure exceeds the reserved size of the C2PA Claim Signature box, multiple step processing must be repeated with a larger padding size chosen in <<_create_a_temporary_claim_and_signature>>. Revocation information retrieved during the previous attempt should be reusable if it is still within its validity interval (https://datatracker.ietf.org/doc/html/rfc6960#section-4.2.2.1[RFC 6960 section 4.2.2.1]), but a new time-stamp will be required on the new claim with the file offsets changed as the result of added padding.
